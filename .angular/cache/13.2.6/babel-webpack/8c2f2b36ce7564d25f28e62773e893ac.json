{"ast":null,"code":"const transitionEnd = (el, callback) => {\n  let unRegTrans;\n  const opts = {\n    passive: true\n  };\n\n  const unregister = () => {\n    if (unRegTrans) {\n      unRegTrans();\n    }\n  };\n\n  const onTransitionEnd = ev => {\n    if (el === ev.target) {\n      unregister();\n      callback(ev);\n    }\n  };\n\n  if (el) {\n    el.addEventListener('webkitTransitionEnd', onTransitionEnd, opts);\n    el.addEventListener('transitionend', onTransitionEnd, opts);\n\n    unRegTrans = () => {\n      el.removeEventListener('webkitTransitionEnd', onTransitionEnd, opts);\n      el.removeEventListener('transitionend', onTransitionEnd, opts);\n    };\n  }\n\n  return unregister;\n};\n\nconst CSS_VALUE_REGEX = /(^-?\\d*\\.?\\d*)(.*)/;\nconst DURATION_MIN = 32;\nconst TRANSITION_END_FALLBACK_PADDING_MS = 400;\nconst TRANSFORM_PROPS = {\n  'translateX': 1,\n  'translateY': 1,\n  'translateZ': 1,\n  'scale': 1,\n  'scaleX': 1,\n  'scaleY': 1,\n  'scaleZ': 1,\n  'rotate': 1,\n  'rotateX': 1,\n  'rotateY': 1,\n  'rotateZ': 1,\n  'skewX': 1,\n  'skewY': 1,\n  'perspective': 1\n};\nconst win = typeof window !== 'undefined' ? window : {};\nconst raf = win.requestAnimationFrame ? win.requestAnimationFrame.bind(win) : f => f(Date.now());\n\nclass Animator {\n  constructor() {\n    this._hasDur = false;\n    this._hasTweenEffect = false;\n    this._isAsync = false;\n    this._isReverse = false;\n    this._destroyed = false;\n    this.hasChildren = false;\n    this.isPlaying = false;\n    this.hasCompleted = false;\n  }\n\n  addElement(el) {\n    if (el != null) {\n      if (el.length > 0) {\n        for (let i = 0; i < el.length; i++) {\n          this._addEl(el[i]);\n        }\n      } else {\n        this._addEl(el);\n      }\n    }\n\n    return this;\n  }\n  /**\r\n   * NO DOM\r\n   */\n\n\n  _addEl(el) {\n    if (el.nodeType === 1) {\n      (this._elements = this._elements || []).push(el);\n    }\n  }\n  /**\r\n   * Add a child animation to this animation.\r\n   */\n\n\n  add(childAnimation) {\n    childAnimation.parent = this;\n    this.hasChildren = true;\n    (this._childAnimations = this._childAnimations || []).push(childAnimation);\n    return this;\n  }\n  /**\r\n   * Get the duration of this animation. If this animation does\r\n   * not have a duration, then it'll get the duration from its parent.\r\n   */\n\n\n  getDuration(opts) {\n    if (opts && opts.duration !== undefined) {\n      return opts.duration;\n    } else if (this._duration !== undefined) {\n      return this._duration;\n    } else if (this.parent) {\n      return this.parent.getDuration();\n    }\n\n    return 0;\n  }\n  /**\r\n   * Returns if the animation is a root one.\r\n   */\n\n\n  isRoot() {\n    return !this.parent;\n  }\n  /**\r\n   * Set the duration for this animation.\r\n   */\n\n\n  duration(milliseconds) {\n    this._duration = milliseconds;\n    return this;\n  }\n  /**\r\n   * Get the easing of this animation. If this animation does\r\n   * not have an easing, then it'll get the easing from its parent.\r\n   */\n\n\n  getEasing() {\n    if (this._isReverse && this._reversedEasingName !== undefined) {\n      return this._reversedEasingName;\n    }\n\n    return this._easingName !== undefined ? this._easingName : this.parent && this.parent.getEasing() || null;\n  }\n  /**\r\n   * Set the easing for this animation.\r\n   */\n\n\n  easing(name) {\n    this._easingName = name;\n    return this;\n  }\n  /**\r\n   * Set the easing for this reversed animation.\r\n   */\n\n\n  easingReverse(name) {\n    this._reversedEasingName = name;\n    return this;\n  }\n  /**\r\n   * Add the \"from\" value for a specific property.\r\n   */\n\n\n  from(prop, val) {\n    this._addProp('from', prop, val);\n\n    return this;\n  }\n  /**\r\n   * Add the \"to\" value for a specific property.\r\n   */\n\n\n  to(prop, val, clearProperyAfterTransition = false) {\n    const fx = this._addProp('to', prop, val);\n\n    if (clearProperyAfterTransition) {\n      // if this effect is a transform then clear the transform effect\n      // otherwise just clear the actual property\n      this.afterClearStyles(fx.trans ? ['transform', '-webkit-transform'] : [prop]);\n    }\n\n    return this;\n  }\n  /**\r\n   * Shortcut to add both the \"from\" and \"to\" for the same property.\r\n   */\n\n\n  fromTo(prop, fromVal, toVal, clearProperyAfterTransition) {\n    return this.from(prop, fromVal).to(prop, toVal, clearProperyAfterTransition);\n  }\n  /**\r\n   * NO DOM\r\n   */\n\n\n  _getProp(name) {\n    if (this._fxProperties) {\n      return this._fxProperties.find(prop => prop.effectName === name);\n    }\n\n    return undefined;\n  }\n\n  _addProp(state, prop, val) {\n    let fxProp = this._getProp(prop);\n\n    if (!fxProp) {\n      // first time we've see this EffectProperty\n      const shouldTrans = TRANSFORM_PROPS[prop] === 1;\n      fxProp = {\n        effectName: prop,\n        trans: shouldTrans,\n        // add the will-change property for transforms or opacity\n        wc: shouldTrans ? 'transform' : prop\n      };\n      (this._fxProperties = this._fxProperties || []).push(fxProp);\n    } // add from/to EffectState to the EffectProperty\n\n\n    const fxState = {\n      val,\n      num: 0,\n      effectUnit: ''\n    };\n    fxProp[state] = fxState;\n\n    if (typeof val === 'string' && val.indexOf(' ') < 0) {\n      const r = val.match(CSS_VALUE_REGEX);\n\n      if (r) {\n        const num = parseFloat(r[1]);\n\n        if (!isNaN(num)) {\n          fxState.num = num;\n        }\n\n        fxState.effectUnit = r[0] !== r[2] ? r[2] : '';\n      }\n    } else if (typeof val === 'number') {\n      fxState.num = val;\n    }\n\n    return fxProp;\n  }\n  /**\r\n   * Add CSS class to this animation's elements\r\n   * before the animation begins.\r\n   */\n\n\n  beforeAddClass(className) {\n    (this._beforeAddClasses = this._beforeAddClasses || []).push(className);\n    return this;\n  }\n  /**\r\n   * Remove CSS class from this animation's elements\r\n   * before the animation begins.\r\n   */\n\n\n  beforeRemoveClass(className) {\n    (this._beforeRemoveClasses = this._beforeRemoveClasses || []).push(className);\n    return this;\n  }\n  /**\r\n   * Set CSS inline styles to this animation's elements\r\n   * before the animation begins.\r\n   */\n\n\n  beforeStyles(styles) {\n    this._beforeStyles = styles;\n    return this;\n  }\n  /**\r\n   * Clear CSS inline styles from this animation's elements\r\n   * before the animation begins.\r\n   */\n\n\n  beforeClearStyles(propertyNames) {\n    this._beforeStyles = this._beforeStyles || {};\n\n    for (const prop of propertyNames) {\n      this._beforeStyles[prop] = '';\n    }\n\n    return this;\n  }\n  /**\r\n   * Add a function which contains DOM reads, which will run\r\n   * before the animation begins.\r\n   */\n\n\n  beforeAddRead(domReadFn) {\n    (this._readCallbacks = this._readCallbacks || []).push(domReadFn);\n    return this;\n  }\n  /**\r\n   * Add a function which contains DOM writes, which will run\r\n   * before the animation begins.\r\n   */\n\n\n  beforeAddWrite(domWriteFn) {\n    (this._writeCallbacks = this._writeCallbacks || []).push(domWriteFn);\n    return this;\n  }\n  /**\r\n   * Add CSS class to this animation's elements\r\n   * after the animation finishes.\r\n   */\n\n\n  afterAddClass(className) {\n    (this._afterAddClasses = this._afterAddClasses || []).push(className);\n    return this;\n  }\n  /**\r\n   * Remove CSS class from this animation's elements\r\n   * after the animation finishes.\r\n   */\n\n\n  afterRemoveClass(className) {\n    (this._afterRemoveClasses = this._afterRemoveClasses || []).push(className);\n    return this;\n  }\n  /**\r\n   * Set CSS inline styles to this animation's elements\r\n   * after the animation finishes.\r\n   */\n\n\n  afterStyles(styles) {\n    this._afterStyles = styles;\n    return this;\n  }\n  /**\r\n   * Clear CSS inline styles from this animation's elements\r\n   * after the animation finishes.\r\n   */\n\n\n  afterClearStyles(propertyNames) {\n    this._afterStyles = this._afterStyles || {};\n\n    for (const prop of propertyNames) {\n      this._afterStyles[prop] = '';\n    }\n\n    return this;\n  }\n  /**\r\n   * Play the animation.\r\n   */\n\n\n  play(opts) {\n    // If the animation was already invalidated (it did finish), do nothing\n    if (this._destroyed) {\n      return;\n    } // this is the top level animation and is in full control\n    // of when the async play() should actually kick off\n    // if there is no duration then it'll set the TO property immediately\n    // if there is a duration, then it'll stage all animations at the\n    // FROM property and transition duration, wait a few frames, then\n    // kick off the animation by setting the TO property for each animation\n\n\n    this._isAsync = this._hasDuration(opts); // ensure all past transition end events have been cleared\n\n    this._clearAsync(); // recursively kicks off the correct progress step for each child animation\n    // ******** DOM WRITE ****************\n\n\n    this._playInit(opts); // doubling up RAFs since this animation was probably triggered\n    // from an input event, and just having one RAF would have this code\n    // run within the same frame as the triggering input event, and the\n    // input event probably already did way too much work for one frame\n\n\n    raf(() => {\n      raf(() => {\n        this._playDomInspect(opts);\n      });\n    });\n  }\n\n  playAsync(opts) {\n    return new Promise(resolve => {\n      this.onFinish(resolve, {\n        oneTimeCallback: true,\n        clearExistingCallbacks: true\n      });\n      this.play(opts);\n      return this;\n    });\n  }\n\n  playSync() {\n    // If the animation was already invalidated (it did finish), do nothing\n    if (!this._destroyed) {\n      const opts = {\n        duration: 0\n      };\n      this._isAsync = false;\n\n      this._clearAsync();\n\n      this._playInit(opts);\n\n      this._playDomInspect(opts);\n    }\n  }\n  /**\r\n   * DOM WRITE\r\n   * RECURSION\r\n   */\n\n\n  _playInit(opts) {\n    // always default that an animation does not tween\n    // a tween requires that an Animation class has an element\n    // and that it has at least one FROM/TO effect\n    // and that the FROM/TO effect can tween numeric values\n    this._hasTweenEffect = false;\n    this.isPlaying = true;\n    this.hasCompleted = false;\n    this._hasDur = this.getDuration(opts) > DURATION_MIN;\n    const children = this._childAnimations;\n\n    if (children) {\n      for (const child of children) {\n        // ******** DOM WRITE ****************\n        child._playInit(opts);\n      }\n    }\n\n    if (this._hasDur) {\n      // if there is a duration then we want to start at step 0\n      // ******** DOM WRITE ****************\n      this._progress(0); // add the will-change properties\n      // ******** DOM WRITE ****************\n\n\n      this._willChange(true);\n    }\n  }\n  /**\r\n   * DOM WRITE\r\n   * NO RECURSION\r\n   * ROOT ANIMATION\r\n   */\n\n\n  _playDomInspect(opts) {\n    // fire off all the \"before\" function that have DOM READS in them\n    // elements will be in the DOM, however visibily hidden\n    // so we can read their dimensions if need be\n    // ******** DOM READ ****************\n    // ******** DOM WRITE ****************\n    this._beforeAnimation(); // for the root animation only\n    // set the async TRANSITION END event\n    // and run onFinishes when the transition ends\n\n\n    const dur = this.getDuration(opts);\n\n    if (this._isAsync) {\n      this._asyncEnd(dur, true);\n    } // ******** DOM WRITE ****************\n\n\n    this._playProgress(opts);\n\n    if (this._isAsync && !this._destroyed) {\n      // this animation has a duration so we need another RAF\n      // for the CSS TRANSITION properties to kick in\n      raf(() => {\n        this._playToStep(1);\n      });\n    }\n  }\n  /**\r\n   * DOM WRITE\r\n   * RECURSION\r\n   */\n\n\n  _playProgress(opts) {\n    const children = this._childAnimations;\n\n    if (children) {\n      for (const child of children) {\n        // ******** DOM WRITE ****************\n        child._playProgress(opts);\n      }\n    }\n\n    if (this._hasDur) {\n      // set the CSS TRANSITION duration/easing\n      // ******** DOM WRITE ****************\n      this._setTrans(this.getDuration(opts), false);\n    } else {\n      // this animation does not have a duration, so it should not animate\n      // just go straight to the TO properties and call it done\n      // ******** DOM WRITE ****************\n      this._progress(1); // since there was no animation, immediately run the after\n      // ******** DOM WRITE ****************\n\n\n      this._setAfterStyles(); // this animation has no duration, so it has finished\n      // other animations could still be running\n\n\n      this._didFinish(true);\n    }\n  }\n  /**\r\n   * DOM WRITE\r\n   * RECURSION\r\n   */\n\n\n  _playToStep(stepValue) {\n    if (!this._destroyed) {\n      const children = this._childAnimations;\n\n      if (children) {\n        for (const child of children) {\n          // ******** DOM WRITE ****************\n          child._playToStep(stepValue);\n        }\n      }\n\n      if (this._hasDur) {\n        // browser had some time to render everything in place\n        // and the transition duration/easing is set\n        // now set the TO properties which will trigger the transition to begin\n        // ******** DOM WRITE ****************\n        this._progress(stepValue);\n      }\n    }\n  }\n  /**\r\n   * DOM WRITE\r\n   * NO RECURSION\r\n   * ROOT ANIMATION\r\n   */\n\n\n  _asyncEnd(dur, shouldComplete) {\n    const self = this;\n\n    const onTransitionEnd = () => {\n      // congrats! a successful transition completed!\n      // ensure transition end events and timeouts have been cleared\n      self._clearAsync(); // ******** DOM WRITE ****************\n\n\n      self._playEnd(); // transition finished\n\n\n      self._didFinishAll(shouldComplete, true, false);\n    };\n\n    const onTransitionFallback = () => {\n      // oh noz! the transition end event didn't fire in time!\n      // instead the fallback timer when first\n      // if all goes well this fallback should never fire\n      // clear the other async end events from firing\n      self._timerId = undefined;\n\n      self._clearAsync(); // set the after styles\n      // ******** DOM WRITE ****************\n\n\n      self._playEnd(shouldComplete ? 1 : 0); // transition finished\n\n\n      self._didFinishAll(shouldComplete, true, false);\n    }; // set the TRANSITION END event on one of the transition elements\n\n\n    self._unregisterTrnsEnd = transitionEnd(self._transEl(), onTransitionEnd); // set a fallback timeout if the transition end event never fires, or is too slow\n    // transition end fallback: (animation duration + XXms)\n\n    self._timerId = setTimeout(onTransitionFallback, dur + TRANSITION_END_FALLBACK_PADDING_MS);\n  }\n  /**\r\n   * DOM WRITE\r\n   * RECURSION\r\n   */\n\n\n  _playEnd(stepValue) {\n    const children = this._childAnimations;\n\n    if (children) {\n      for (const child of children) {\n        // ******** DOM WRITE ****************\n        child._playEnd(stepValue);\n      }\n    }\n\n    if (this._hasDur) {\n      if (stepValue !== undefined) {\n        // too late to have a smooth animation, just finish it\n        // ******** DOM WRITE ****************\n        this._setTrans(0, true); // ensure the ending progress step gets rendered\n        // ******** DOM WRITE ****************\n\n\n        this._progress(stepValue);\n      } // set the after styles\n      // ******** DOM WRITE ****************\n\n\n      this._setAfterStyles(); // remove the will-change properties\n      // ******** DOM WRITE ****************\n\n\n      this._willChange(false);\n    }\n  }\n  /**\r\n   * NO DOM\r\n   * RECURSION\r\n   */\n\n\n  _hasDuration(opts) {\n    if (this.getDuration(opts) > DURATION_MIN) {\n      return true;\n    }\n\n    const children = this._childAnimations;\n\n    if (children) {\n      for (const child of children) {\n        if (child._hasDuration(opts)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n  /**\r\n   * NO DOM\r\n   * RECURSION\r\n   */\n\n\n  _hasDomReads() {\n    if (this._readCallbacks && this._readCallbacks.length > 0) {\n      return true;\n    }\n\n    const children = this._childAnimations;\n\n    if (children) {\n      for (const child of children) {\n        if (child._hasDomReads()) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n  /**\r\n   * Immediately stop at the end of the animation.\r\n   */\n\n\n  stop(stepValue = 1) {\n    // ensure all past transition end events have been cleared\n    this._clearAsync();\n\n    this._hasDur = true;\n\n    this._playEnd(stepValue);\n  }\n  /**\r\n   * NO DOM\r\n   * NO RECURSION\r\n   */\n\n\n  _clearAsync() {\n    if (this._unregisterTrnsEnd) {\n      this._unregisterTrnsEnd();\n    }\n\n    if (this._timerId) {\n      clearTimeout(this._timerId);\n    }\n\n    this._timerId = this._unregisterTrnsEnd = undefined;\n  }\n  /**\r\n   * DOM WRITE\r\n   * NO RECURSION\r\n   */\n\n\n  _progress(stepValue) {\n    // bread 'n butter\n    let val;\n    const elements = this._elements;\n    const effects = this._fxProperties;\n\n    if (!elements || elements.length === 0 || !effects || this._destroyed) {\n      return;\n    } // flip the number if we're going in reverse\n\n\n    if (this._isReverse) {\n      stepValue = 1 - stepValue;\n    }\n\n    let i = 0;\n    let j = 0;\n    let finalTransform = '';\n    let fx;\n\n    for (i = 0; i < effects.length; i++) {\n      fx = effects[i];\n\n      if (fx.from && fx.to) {\n        const fromNum = fx.from.num;\n        const toNum = fx.to.num;\n        const tweenEffect = fromNum !== toNum;\n\n        if (tweenEffect) {\n          this._hasTweenEffect = true;\n        }\n\n        if (stepValue === 0) {\n          // FROM\n          val = fx.from.val;\n        } else if (stepValue === 1) {\n          // TO\n          val = fx.to.val;\n        } else if (tweenEffect) {\n          // EVERYTHING IN BETWEEN\n          const valNum = (toNum - fromNum) * stepValue + fromNum;\n          const unit = fx.to.effectUnit;\n          val = valNum + unit;\n        }\n\n        if (val !== null) {\n          const prop = fx.effectName;\n\n          if (fx.trans) {\n            finalTransform += prop + '(' + val + ') ';\n          } else {\n            for (j = 0; j < elements.length; j++) {\n              // ******** DOM WRITE ****************\n              elements[j].style.setProperty(prop, val);\n            }\n          }\n        }\n      }\n    } // place all transforms on the same property\n\n\n    if (finalTransform.length > 0) {\n      if (!this._isReverse && stepValue !== 1 || this._isReverse && stepValue !== 0) {\n        finalTransform += 'translateZ(0px)';\n      }\n\n      for (i = 0; i < elements.length; i++) {\n        // ******** DOM WRITE ****************\n        elements[i].style.setProperty('transform', finalTransform);\n        elements[i].style.setProperty('-webkit-transform', finalTransform);\n      }\n    }\n  }\n  /**\r\n   * DOM WRITE\r\n   * NO RECURSION\r\n   */\n\n\n  _setTrans(dur, forcedLinearEasing) {\n    // Transition is not enabled if there are not effects\n    const elements = this._elements;\n\n    if (!elements || elements.length === 0 || !this._fxProperties) {\n      return;\n    } // set the TRANSITION properties inline on the element\n\n\n    const easing = forcedLinearEasing ? 'linear' : this.getEasing();\n    const durString = dur + 'ms';\n\n    for (const {\n      style\n    } of elements) {\n      if (dur > 0) {\n        // ******** DOM WRITE ****************\n        style.transitionDuration = durString; // each animation can have a different easing\n\n        if (easing !== null) {\n          // ******** DOM WRITE ****************\n          style.transitionTimingFunction = easing;\n        }\n      } else {\n        style.transitionDuration = '0';\n      }\n    }\n  }\n  /**\r\n   * DOM READ\r\n   * DOM WRITE\r\n   * RECURSION\r\n   */\n\n\n  _beforeAnimation() {\n    // fire off all the \"before\" function that have DOM READS in them\n    // elements will be in the DOM, however visibily hidden\n    // so we can read their dimensions if need be\n    // ******** DOM READ ****************\n    this._fireBeforeReadFunc(); // ******** DOM READS ABOVE / DOM WRITES BELOW ****************\n    // fire off all the \"before\" function that have DOM WRITES in them\n    // ******** DOM WRITE ****************\n\n\n    this._fireBeforeWriteFunc(); // stage all of the before css classes and inline styles\n    // ******** DOM WRITE ****************\n\n\n    this._setBeforeStyles();\n  }\n  /**\r\n   * DOM WRITE\r\n   * RECURSION\r\n   */\n\n\n  _setBeforeStyles() {\n    const children = this._childAnimations;\n\n    if (children) {\n      for (const child of children) {\n        child._setBeforeStyles();\n      }\n    }\n\n    const elements = this._elements; // before the animations have started\n    // only set before styles if animation is not reversed\n\n    if (!elements || elements.length === 0 || this._isReverse) {\n      return;\n    }\n\n    const addClasses = this._beforeAddClasses;\n    const removeClasses = this._beforeRemoveClasses;\n\n    for (const el of elements) {\n      const elementClassList = el.classList; // css classes to add before the animation\n\n      if (addClasses) {\n        for (const c of addClasses) {\n          // ******** DOM WRITE ****************\n          elementClassList.add(c);\n        }\n      } // css classes to remove before the animation\n\n\n      if (removeClasses) {\n        for (const c of removeClasses) {\n          // ******** DOM WRITE ****************\n          elementClassList.remove(c);\n        }\n      } // inline styles to add before the animation\n\n\n      if (this._beforeStyles) {\n        for (const [key, value] of Object.entries(this._beforeStyles)) {\n          // ******** DOM WRITE ****************\n          el.style.setProperty(key, value);\n        }\n      }\n    }\n  }\n  /**\r\n   * DOM READ\r\n   * RECURSION\r\n   */\n\n\n  _fireBeforeReadFunc() {\n    const children = this._childAnimations;\n\n    if (children) {\n      for (const child of children) {\n        // ******** DOM READ ****************\n        child._fireBeforeReadFunc();\n      }\n    }\n\n    const readFunctions = this._readCallbacks;\n\n    if (readFunctions) {\n      for (const callback of readFunctions) {\n        // ******** DOM READ ****************\n        callback();\n      }\n    }\n  }\n  /**\r\n   * DOM WRITE\r\n   * RECURSION\r\n   */\n\n\n  _fireBeforeWriteFunc() {\n    const children = this._childAnimations;\n\n    if (children) {\n      for (const child of children) {\n        // ******** DOM WRITE ****************\n        child._fireBeforeWriteFunc();\n      }\n    }\n\n    const writeFunctions = this._writeCallbacks;\n\n    if (writeFunctions) {\n      for (const callback of writeFunctions) {\n        // ******** DOM WRITE ****************\n        callback();\n      }\n    }\n  }\n  /**\r\n   * DOM WRITE\r\n   */\n\n\n  _setAfterStyles() {\n    const elements = this._elements;\n\n    if (!elements) {\n      return;\n    }\n\n    for (const el of elements) {\n      const elementClassList = el.classList; // remove the transition duration/easing\n      // ******** DOM WRITE ****************\n\n      el.style.transitionDuration = el.style.transitionTimingFunction = '';\n\n      if (this._isReverse) {\n        // finished in reverse direction\n        // css classes that were added before the animation should be removed\n        const beforeAddClasses = this._beforeAddClasses;\n\n        if (beforeAddClasses) {\n          for (const c of beforeAddClasses) {\n            elementClassList.remove(c);\n          }\n        } // css classes that were removed before the animation should be added\n\n\n        const beforeRemoveClasses = this._beforeRemoveClasses;\n\n        if (beforeRemoveClasses) {\n          for (const c of beforeRemoveClasses) {\n            elementClassList.add(c);\n          }\n        } // inline styles that were added before the animation should be removed\n\n\n        const beforeStyles = this._beforeStyles;\n\n        if (beforeStyles) {\n          for (const propName of Object.keys(beforeStyles)) {\n            // ******** DOM WRITE ****************\n            el.style.removeProperty(propName);\n          }\n        }\n      } else {\n        // finished in forward direction\n        // css classes to add after the animation\n        const afterAddClasses = this._afterAddClasses;\n\n        if (afterAddClasses) {\n          for (const c of afterAddClasses) {\n            // ******** DOM WRITE ****************\n            elementClassList.add(c);\n          }\n        } // css classes to remove after the animation\n\n\n        const afterRemoveClasses = this._afterRemoveClasses;\n\n        if (afterRemoveClasses) {\n          for (const c of afterRemoveClasses) {\n            // ******** DOM WRITE ****************\n            elementClassList.remove(c);\n          }\n        } // inline styles to add after the animation\n\n\n        const afterStyles = this._afterStyles;\n\n        if (afterStyles) {\n          for (const [key, value] of Object.entries(afterStyles)) {\n            el.style.setProperty(key, value);\n          }\n        }\n      }\n    }\n  }\n  /**\r\n   * DOM WRITE\r\n   * NO RECURSION\r\n   */\n\n\n  _willChange(addWillChange) {\n    let wc;\n    const effects = this._fxProperties;\n    let willChange;\n\n    if (addWillChange && effects) {\n      wc = [];\n\n      for (const effect of effects) {\n        const propWC = effect.wc;\n\n        if (propWC === 'webkitTransform') {\n          wc.push('transform', '-webkit-transform');\n        } else if (propWC !== undefined) {\n          wc.push(propWC);\n        }\n      }\n\n      willChange = wc.join(',');\n    } else {\n      willChange = '';\n    }\n\n    const elements = this._elements;\n\n    if (elements) {\n      for (const el of elements) {\n        // ******** DOM WRITE ****************\n        el.style.setProperty('will-change', willChange);\n      }\n    }\n  }\n  /**\r\n   * Start the animation with a user controlled progress.\r\n   */\n\n\n  progressStart() {\n    // ensure all past transition end events have been cleared\n    this._clearAsync(); // ******** DOM READ/WRITE ****************\n\n\n    this._beforeAnimation(); // ******** DOM WRITE ****************\n\n\n    this._progressStart();\n  }\n  /**\r\n   * DOM WRITE\r\n   * RECURSION\r\n   */\n\n\n  _progressStart() {\n    const children = this._childAnimations;\n\n    if (children) {\n      for (const child of children) {\n        // ******** DOM WRITE ****************\n        child._progressStart();\n      }\n    } // force no duration, linear easing\n    // ******** DOM WRITE ****************\n\n\n    this._setTrans(0, true); // ******** DOM WRITE ****************\n\n\n    this._willChange(true);\n  }\n  /**\r\n   * Set the progress step for this animation.\r\n   * progressStep() is not debounced, so it should not be called faster than 60FPS.\r\n   */\n\n\n  progressStep(stepValue) {\n    // only update if the last update was more than 16ms ago\n    stepValue = Math.min(1, Math.max(0, stepValue));\n    const children = this._childAnimations;\n\n    if (children) {\n      for (const child of children) {\n        // ******** DOM WRITE ****************\n        child.progressStep(stepValue);\n      }\n    } // ******** DOM WRITE ****************\n\n\n    this._progress(stepValue);\n  }\n  /**\r\n   * End the progress animation.\r\n   */\n\n\n  progressEnd(shouldComplete, currentStepValue, dur = -1) {\n    if (this._isReverse) {\n      // if the animation is going in reverse then\n      // flip the step value: 0 becomes 1, 1 becomes 0\n      currentStepValue = 1 - currentStepValue;\n    }\n\n    const stepValue = shouldComplete ? 1 : 0;\n    const diff = Math.abs(currentStepValue - stepValue);\n\n    if (dur < 0) {\n      dur = this._duration || 0;\n    } else if (diff < 0.05) {\n      dur = 0;\n    }\n\n    this._isAsync = dur > 30;\n\n    this._progressEnd(shouldComplete, stepValue, dur, this._isAsync);\n\n    if (this._isAsync) {\n      // for the root animation only\n      // set the async TRANSITION END event\n      // and run onFinishes when the transition ends\n      // ******** DOM WRITE ****************\n      this._asyncEnd(dur, shouldComplete); // this animation has a duration so we need another RAF\n      // for the CSS TRANSITION properties to kick in\n\n\n      if (!this._destroyed) {\n        raf(() => {\n          this._playToStep(stepValue);\n        });\n      }\n    }\n  }\n  /**\r\n   * DOM WRITE\r\n   * RECURSION\r\n   */\n\n\n  _progressEnd(shouldComplete, stepValue, dur, isAsync) {\n    const children = this._childAnimations;\n\n    if (children) {\n      for (const child of children) {\n        // ******** DOM WRITE ****************\n        child._progressEnd(shouldComplete, stepValue, dur, isAsync);\n      }\n    }\n\n    if (!isAsync) {\n      // stop immediately\n      // set all the animations to their final position\n      // ******** DOM WRITE ****************\n      this._progress(stepValue);\n\n      this._willChange(false);\n\n      this._setAfterStyles();\n\n      this._didFinish(shouldComplete);\n    } else {\n      // animate it back to it's ending position\n      this.isPlaying = true;\n      this.hasCompleted = false;\n      this._hasDur = true; // ******** DOM WRITE ****************\n\n      this._willChange(true);\n\n      this._setTrans(dur, false);\n    }\n  }\n  /**\r\n   * Add a callback to fire when the animation has finished.\r\n   */\n\n\n  onFinish(callback, opts) {\n    if (opts && opts.clearExistingCallbacks) {\n      this._onFinishCallbacks = this._onFinishOneTimeCallbacks = undefined;\n    }\n\n    if (opts && opts.oneTimeCallback) {\n      this._onFinishOneTimeCallbacks = this._onFinishOneTimeCallbacks || [];\n\n      this._onFinishOneTimeCallbacks.push(callback);\n    } else {\n      this._onFinishCallbacks = this._onFinishCallbacks || [];\n\n      this._onFinishCallbacks.push(callback);\n    }\n\n    return this;\n  }\n  /**\r\n   * NO DOM\r\n   * RECURSION\r\n   */\n\n\n  _didFinishAll(hasCompleted, finishAsyncAnimations, finishNoDurationAnimations) {\n    const children = this._childAnimations;\n\n    if (children) {\n      for (const child of children) {\n        child._didFinishAll(hasCompleted, finishAsyncAnimations, finishNoDurationAnimations);\n      }\n    }\n\n    if (finishAsyncAnimations && this._isAsync || finishNoDurationAnimations && !this._isAsync) {\n      this._didFinish(hasCompleted);\n    }\n  }\n  /**\r\n   * NO RECURSION\r\n   */\n\n\n  _didFinish(hasCompleted) {\n    this.isPlaying = false;\n    this.hasCompleted = hasCompleted;\n\n    if (this._onFinishCallbacks) {\n      // run all finish callbacks\n      for (const callback of this._onFinishCallbacks) {\n        callback(this);\n      }\n    }\n\n    if (this._onFinishOneTimeCallbacks) {\n      // run all \"onetime\" finish callbacks\n      for (const callback of this._onFinishOneTimeCallbacks) {\n        callback(this);\n      }\n\n      this._onFinishOneTimeCallbacks.length = 0;\n    }\n  }\n  /**\r\n   * Reverse the animation.\r\n   */\n\n\n  reverse(shouldReverse = true) {\n    const children = this._childAnimations;\n\n    if (children) {\n      for (const child of children) {\n        child.reverse(shouldReverse);\n      }\n    }\n\n    this._isReverse = !!shouldReverse;\n    return this;\n  }\n  /**\r\n   * Recursively destroy this animation and all child animations.\r\n   */\n\n\n  destroy() {\n    this._didFinish(false);\n\n    this._destroyed = true;\n    const children = this._childAnimations;\n\n    if (children) {\n      for (const child of children) {\n        child.destroy();\n      }\n    }\n\n    this._clearAsync();\n\n    if (this._elements) {\n      this._elements.length = 0;\n    }\n\n    if (this._readCallbacks) {\n      this._readCallbacks.length = 0;\n    }\n\n    if (this._writeCallbacks) {\n      this._writeCallbacks.length = 0;\n    }\n\n    this.parent = undefined;\n\n    if (this._childAnimations) {\n      this._childAnimations.length = 0;\n    }\n\n    if (this._onFinishCallbacks) {\n      this._onFinishCallbacks.length = 0;\n    }\n\n    if (this._onFinishOneTimeCallbacks) {\n      this._onFinishOneTimeCallbacks.length = 0;\n    }\n  }\n  /**\r\n   * NO DOM\r\n   */\n\n\n  _transEl() {\n    // get the lowest level element that has an Animator\n    const children = this._childAnimations;\n\n    if (children) {\n      for (const child of children) {\n        const targetEl = child._transEl();\n\n        if (targetEl) {\n          return targetEl;\n        }\n      }\n    }\n\n    return this._hasTweenEffect && this._hasDur && this._elements !== undefined && this._elements.length > 0 ? this._elements[0] : null;\n  }\n\n}\n\nconst create = (animationBuilder, baseEl, opts) => {\n  if (animationBuilder) {\n    return animationBuilder(Animator, baseEl, opts);\n  }\n\n  return Promise.resolve(new Animator());\n};\n\nexport { create };","map":{"version":3,"sources":["/home/ivan/HACKUPC2022/Join/node_modules/ionic-mqtt/node_modules/@ionic/core/dist/esm/index-69c37885.js"],"names":["transitionEnd","el","callback","unRegTrans","opts","passive","unregister","onTransitionEnd","ev","target","addEventListener","removeEventListener","CSS_VALUE_REGEX","DURATION_MIN","TRANSITION_END_FALLBACK_PADDING_MS","TRANSFORM_PROPS","win","window","raf","requestAnimationFrame","bind","f","Date","now","Animator","constructor","_hasDur","_hasTweenEffect","_isAsync","_isReverse","_destroyed","hasChildren","isPlaying","hasCompleted","addElement","length","i","_addEl","nodeType","_elements","push","add","childAnimation","parent","_childAnimations","getDuration","duration","undefined","_duration","isRoot","milliseconds","getEasing","_reversedEasingName","_easingName","easing","name","easingReverse","from","prop","val","_addProp","to","clearProperyAfterTransition","fx","afterClearStyles","trans","fromTo","fromVal","toVal","_getProp","_fxProperties","find","effectName","state","fxProp","shouldTrans","wc","fxState","num","effectUnit","indexOf","r","match","parseFloat","isNaN","beforeAddClass","className","_beforeAddClasses","beforeRemoveClass","_beforeRemoveClasses","beforeStyles","styles","_beforeStyles","beforeClearStyles","propertyNames","beforeAddRead","domReadFn","_readCallbacks","beforeAddWrite","domWriteFn","_writeCallbacks","afterAddClass","_afterAddClasses","afterRemoveClass","_afterRemoveClasses","afterStyles","_afterStyles","play","_hasDuration","_clearAsync","_playInit","_playDomInspect","playAsync","Promise","resolve","onFinish","oneTimeCallback","clearExistingCallbacks","playSync","children","child","_progress","_willChange","_beforeAnimation","dur","_asyncEnd","_playProgress","_playToStep","_setTrans","_setAfterStyles","_didFinish","stepValue","shouldComplete","self","_playEnd","_didFinishAll","onTransitionFallback","_timerId","_unregisterTrnsEnd","_transEl","setTimeout","_hasDomReads","stop","clearTimeout","elements","effects","j","finalTransform","fromNum","toNum","tweenEffect","valNum","unit","style","setProperty","forcedLinearEasing","durString","transitionDuration","transitionTimingFunction","_fireBeforeReadFunc","_fireBeforeWriteFunc","_setBeforeStyles","addClasses","removeClasses","elementClassList","classList","c","remove","key","value","Object","entries","readFunctions","writeFunctions","beforeAddClasses","beforeRemoveClasses","propName","keys","removeProperty","afterAddClasses","afterRemoveClasses","addWillChange","willChange","effect","propWC","join","progressStart","_progressStart","progressStep","Math","min","max","progressEnd","currentStepValue","diff","abs","_progressEnd","isAsync","_onFinishCallbacks","_onFinishOneTimeCallbacks","finishAsyncAnimations","finishNoDurationAnimations","reverse","shouldReverse","destroy","targetEl","create","animationBuilder","baseEl"],"mappings":"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","sourcesContent":["const transitionEnd = (el, callback) => {\r\n    let unRegTrans;\r\n    const opts = { passive: true };\r\n    const unregister = () => {\r\n        if (unRegTrans) {\r\n            unRegTrans();\r\n        }\r\n    };\r\n    const onTransitionEnd = (ev) => {\r\n        if (el === ev.target) {\r\n            unregister();\r\n            callback(ev);\r\n        }\r\n    };\r\n    if (el) {\r\n        el.addEventListener('webkitTransitionEnd', onTransitionEnd, opts);\r\n        el.addEventListener('transitionend', onTransitionEnd, opts);\r\n        unRegTrans = () => {\r\n            el.removeEventListener('webkitTransitionEnd', onTransitionEnd, opts);\r\n            el.removeEventListener('transitionend', onTransitionEnd, opts);\r\n        };\r\n    }\r\n    return unregister;\r\n};\n\nconst CSS_VALUE_REGEX = /(^-?\\d*\\.?\\d*)(.*)/;\r\nconst DURATION_MIN = 32;\r\nconst TRANSITION_END_FALLBACK_PADDING_MS = 400;\r\nconst TRANSFORM_PROPS = {\r\n    'translateX': 1,\r\n    'translateY': 1,\r\n    'translateZ': 1,\r\n    'scale': 1,\r\n    'scaleX': 1,\r\n    'scaleY': 1,\r\n    'scaleZ': 1,\r\n    'rotate': 1,\r\n    'rotateX': 1,\r\n    'rotateY': 1,\r\n    'rotateZ': 1,\r\n    'skewX': 1,\r\n    'skewY': 1,\r\n    'perspective': 1\r\n};\r\nconst win = typeof window !== 'undefined' ? window : {};\r\nconst raf = win.requestAnimationFrame\r\n    ? win.requestAnimationFrame.bind(win)\r\n    : (f) => f(Date.now());\r\nclass Animator {\r\n    constructor() {\r\n        this._hasDur = false;\r\n        this._hasTweenEffect = false;\r\n        this._isAsync = false;\r\n        this._isReverse = false;\r\n        this._destroyed = false;\r\n        this.hasChildren = false;\r\n        this.isPlaying = false;\r\n        this.hasCompleted = false;\r\n    }\r\n    addElement(el) {\r\n        if (el != null) {\r\n            if (el.length > 0) {\r\n                for (let i = 0; i < el.length; i++) {\r\n                    this._addEl(el[i]);\r\n                }\r\n            }\r\n            else {\r\n                this._addEl(el);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * NO DOM\r\n     */\r\n    _addEl(el) {\r\n        if (el.nodeType === 1) {\r\n            (this._elements = this._elements || []).push(el);\r\n        }\r\n    }\r\n    /**\r\n     * Add a child animation to this animation.\r\n     */\r\n    add(childAnimation) {\r\n        childAnimation.parent = this;\r\n        this.hasChildren = true;\r\n        (this._childAnimations = this._childAnimations || []).push(childAnimation);\r\n        return this;\r\n    }\r\n    /**\r\n     * Get the duration of this animation. If this animation does\r\n     * not have a duration, then it'll get the duration from its parent.\r\n     */\r\n    getDuration(opts) {\r\n        if (opts && opts.duration !== undefined) {\r\n            return opts.duration;\r\n        }\r\n        else if (this._duration !== undefined) {\r\n            return this._duration;\r\n        }\r\n        else if (this.parent) {\r\n            return this.parent.getDuration();\r\n        }\r\n        return 0;\r\n    }\r\n    /**\r\n     * Returns if the animation is a root one.\r\n     */\r\n    isRoot() {\r\n        return !this.parent;\r\n    }\r\n    /**\r\n     * Set the duration for this animation.\r\n     */\r\n    duration(milliseconds) {\r\n        this._duration = milliseconds;\r\n        return this;\r\n    }\r\n    /**\r\n     * Get the easing of this animation. If this animation does\r\n     * not have an easing, then it'll get the easing from its parent.\r\n     */\r\n    getEasing() {\r\n        if (this._isReverse && this._reversedEasingName !== undefined) {\r\n            return this._reversedEasingName;\r\n        }\r\n        return this._easingName !== undefined ? this._easingName : (this.parent && this.parent.getEasing()) || null;\r\n    }\r\n    /**\r\n     * Set the easing for this animation.\r\n     */\r\n    easing(name) {\r\n        this._easingName = name;\r\n        return this;\r\n    }\r\n    /**\r\n     * Set the easing for this reversed animation.\r\n     */\r\n    easingReverse(name) {\r\n        this._reversedEasingName = name;\r\n        return this;\r\n    }\r\n    /**\r\n     * Add the \"from\" value for a specific property.\r\n     */\r\n    from(prop, val) {\r\n        this._addProp('from', prop, val);\r\n        return this;\r\n    }\r\n    /**\r\n     * Add the \"to\" value for a specific property.\r\n     */\r\n    to(prop, val, clearProperyAfterTransition = false) {\r\n        const fx = this._addProp('to', prop, val);\r\n        if (clearProperyAfterTransition) {\r\n            // if this effect is a transform then clear the transform effect\r\n            // otherwise just clear the actual property\r\n            this.afterClearStyles(fx.trans ? ['transform', '-webkit-transform'] : [prop]);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Shortcut to add both the \"from\" and \"to\" for the same property.\r\n     */\r\n    fromTo(prop, fromVal, toVal, clearProperyAfterTransition) {\r\n        return this.from(prop, fromVal).to(prop, toVal, clearProperyAfterTransition);\r\n    }\r\n    /**\r\n     * NO DOM\r\n     */\r\n    _getProp(name) {\r\n        if (this._fxProperties) {\r\n            return this._fxProperties.find(prop => prop.effectName === name);\r\n        }\r\n        return undefined;\r\n    }\r\n    _addProp(state, prop, val) {\r\n        let fxProp = this._getProp(prop);\r\n        if (!fxProp) {\r\n            // first time we've see this EffectProperty\r\n            const shouldTrans = (TRANSFORM_PROPS[prop] === 1);\r\n            fxProp = {\r\n                effectName: prop,\r\n                trans: shouldTrans,\r\n                // add the will-change property for transforms or opacity\r\n                wc: (shouldTrans ? 'transform' : prop)\r\n            };\r\n            (this._fxProperties = this._fxProperties || []).push(fxProp);\r\n        }\r\n        // add from/to EffectState to the EffectProperty\r\n        const fxState = {\r\n            val,\r\n            num: 0,\r\n            effectUnit: '',\r\n        };\r\n        fxProp[state] = fxState;\r\n        if (typeof val === 'string' && val.indexOf(' ') < 0) {\r\n            const r = val.match(CSS_VALUE_REGEX);\r\n            if (r) {\r\n                const num = parseFloat(r[1]);\r\n                if (!isNaN(num)) {\r\n                    fxState.num = num;\r\n                }\r\n                fxState.effectUnit = (r[0] !== r[2] ? r[2] : '');\r\n            }\r\n        }\r\n        else if (typeof val === 'number') {\r\n            fxState.num = val;\r\n        }\r\n        return fxProp;\r\n    }\r\n    /**\r\n     * Add CSS class to this animation's elements\r\n     * before the animation begins.\r\n     */\r\n    beforeAddClass(className) {\r\n        (this._beforeAddClasses = this._beforeAddClasses || []).push(className);\r\n        return this;\r\n    }\r\n    /**\r\n     * Remove CSS class from this animation's elements\r\n     * before the animation begins.\r\n     */\r\n    beforeRemoveClass(className) {\r\n        (this._beforeRemoveClasses = this._beforeRemoveClasses || []).push(className);\r\n        return this;\r\n    }\r\n    /**\r\n     * Set CSS inline styles to this animation's elements\r\n     * before the animation begins.\r\n     */\r\n    beforeStyles(styles) {\r\n        this._beforeStyles = styles;\r\n        return this;\r\n    }\r\n    /**\r\n     * Clear CSS inline styles from this animation's elements\r\n     * before the animation begins.\r\n     */\r\n    beforeClearStyles(propertyNames) {\r\n        this._beforeStyles = this._beforeStyles || {};\r\n        for (const prop of propertyNames) {\r\n            this._beforeStyles[prop] = '';\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Add a function which contains DOM reads, which will run\r\n     * before the animation begins.\r\n     */\r\n    beforeAddRead(domReadFn) {\r\n        (this._readCallbacks = this._readCallbacks || []).push(domReadFn);\r\n        return this;\r\n    }\r\n    /**\r\n     * Add a function which contains DOM writes, which will run\r\n     * before the animation begins.\r\n     */\r\n    beforeAddWrite(domWriteFn) {\r\n        (this._writeCallbacks = this._writeCallbacks || []).push(domWriteFn);\r\n        return this;\r\n    }\r\n    /**\r\n     * Add CSS class to this animation's elements\r\n     * after the animation finishes.\r\n     */\r\n    afterAddClass(className) {\r\n        (this._afterAddClasses = this._afterAddClasses || []).push(className);\r\n        return this;\r\n    }\r\n    /**\r\n     * Remove CSS class from this animation's elements\r\n     * after the animation finishes.\r\n     */\r\n    afterRemoveClass(className) {\r\n        (this._afterRemoveClasses = this._afterRemoveClasses || []).push(className);\r\n        return this;\r\n    }\r\n    /**\r\n     * Set CSS inline styles to this animation's elements\r\n     * after the animation finishes.\r\n     */\r\n    afterStyles(styles) {\r\n        this._afterStyles = styles;\r\n        return this;\r\n    }\r\n    /**\r\n     * Clear CSS inline styles from this animation's elements\r\n     * after the animation finishes.\r\n     */\r\n    afterClearStyles(propertyNames) {\r\n        this._afterStyles = this._afterStyles || {};\r\n        for (const prop of propertyNames) {\r\n            this._afterStyles[prop] = '';\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Play the animation.\r\n     */\r\n    play(opts) {\r\n        // If the animation was already invalidated (it did finish), do nothing\r\n        if (this._destroyed) {\r\n            return;\r\n        }\r\n        // this is the top level animation and is in full control\r\n        // of when the async play() should actually kick off\r\n        // if there is no duration then it'll set the TO property immediately\r\n        // if there is a duration, then it'll stage all animations at the\r\n        // FROM property and transition duration, wait a few frames, then\r\n        // kick off the animation by setting the TO property for each animation\r\n        this._isAsync = this._hasDuration(opts);\r\n        // ensure all past transition end events have been cleared\r\n        this._clearAsync();\r\n        // recursively kicks off the correct progress step for each child animation\r\n        // ******** DOM WRITE ****************\r\n        this._playInit(opts);\r\n        // doubling up RAFs since this animation was probably triggered\r\n        // from an input event, and just having one RAF would have this code\r\n        // run within the same frame as the triggering input event, and the\r\n        // input event probably already did way too much work for one frame\r\n        raf(() => {\r\n            raf(() => {\r\n                this._playDomInspect(opts);\r\n            });\r\n        });\r\n    }\r\n    playAsync(opts) {\r\n        return new Promise(resolve => {\r\n            this.onFinish(resolve, { oneTimeCallback: true, clearExistingCallbacks: true });\r\n            this.play(opts);\r\n            return this;\r\n        });\r\n    }\r\n    playSync() {\r\n        // If the animation was already invalidated (it did finish), do nothing\r\n        if (!this._destroyed) {\r\n            const opts = { duration: 0 };\r\n            this._isAsync = false;\r\n            this._clearAsync();\r\n            this._playInit(opts);\r\n            this._playDomInspect(opts);\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _playInit(opts) {\r\n        // always default that an animation does not tween\r\n        // a tween requires that an Animation class has an element\r\n        // and that it has at least one FROM/TO effect\r\n        // and that the FROM/TO effect can tween numeric values\r\n        this._hasTweenEffect = false;\r\n        this.isPlaying = true;\r\n        this.hasCompleted = false;\r\n        this._hasDur = (this.getDuration(opts) > DURATION_MIN);\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child._playInit(opts);\r\n            }\r\n        }\r\n        if (this._hasDur) {\r\n            // if there is a duration then we want to start at step 0\r\n            // ******** DOM WRITE ****************\r\n            this._progress(0);\r\n            // add the will-change properties\r\n            // ******** DOM WRITE ****************\r\n            this._willChange(true);\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     * ROOT ANIMATION\r\n     */\r\n    _playDomInspect(opts) {\r\n        // fire off all the \"before\" function that have DOM READS in them\r\n        // elements will be in the DOM, however visibily hidden\r\n        // so we can read their dimensions if need be\r\n        // ******** DOM READ ****************\r\n        // ******** DOM WRITE ****************\r\n        this._beforeAnimation();\r\n        // for the root animation only\r\n        // set the async TRANSITION END event\r\n        // and run onFinishes when the transition ends\r\n        const dur = this.getDuration(opts);\r\n        if (this._isAsync) {\r\n            this._asyncEnd(dur, true);\r\n        }\r\n        // ******** DOM WRITE ****************\r\n        this._playProgress(opts);\r\n        if (this._isAsync && !this._destroyed) {\r\n            // this animation has a duration so we need another RAF\r\n            // for the CSS TRANSITION properties to kick in\r\n            raf(() => {\r\n                this._playToStep(1);\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _playProgress(opts) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child._playProgress(opts);\r\n            }\r\n        }\r\n        if (this._hasDur) {\r\n            // set the CSS TRANSITION duration/easing\r\n            // ******** DOM WRITE ****************\r\n            this._setTrans(this.getDuration(opts), false);\r\n        }\r\n        else {\r\n            // this animation does not have a duration, so it should not animate\r\n            // just go straight to the TO properties and call it done\r\n            // ******** DOM WRITE ****************\r\n            this._progress(1);\r\n            // since there was no animation, immediately run the after\r\n            // ******** DOM WRITE ****************\r\n            this._setAfterStyles();\r\n            // this animation has no duration, so it has finished\r\n            // other animations could still be running\r\n            this._didFinish(true);\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _playToStep(stepValue) {\r\n        if (!this._destroyed) {\r\n            const children = this._childAnimations;\r\n            if (children) {\r\n                for (const child of children) {\r\n                    // ******** DOM WRITE ****************\r\n                    child._playToStep(stepValue);\r\n                }\r\n            }\r\n            if (this._hasDur) {\r\n                // browser had some time to render everything in place\r\n                // and the transition duration/easing is set\r\n                // now set the TO properties which will trigger the transition to begin\r\n                // ******** DOM WRITE ****************\r\n                this._progress(stepValue);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     * ROOT ANIMATION\r\n     */\r\n    _asyncEnd(dur, shouldComplete) {\r\n        const self = this;\r\n        const onTransitionEnd = () => {\r\n            // congrats! a successful transition completed!\r\n            // ensure transition end events and timeouts have been cleared\r\n            self._clearAsync();\r\n            // ******** DOM WRITE ****************\r\n            self._playEnd();\r\n            // transition finished\r\n            self._didFinishAll(shouldComplete, true, false);\r\n        };\r\n        const onTransitionFallback = () => {\r\n            // oh noz! the transition end event didn't fire in time!\r\n            // instead the fallback timer when first\r\n            // if all goes well this fallback should never fire\r\n            // clear the other async end events from firing\r\n            self._timerId = undefined;\r\n            self._clearAsync();\r\n            // set the after styles\r\n            // ******** DOM WRITE ****************\r\n            self._playEnd(shouldComplete ? 1 : 0);\r\n            // transition finished\r\n            self._didFinishAll(shouldComplete, true, false);\r\n        };\r\n        // set the TRANSITION END event on one of the transition elements\r\n        self._unregisterTrnsEnd = transitionEnd(self._transEl(), onTransitionEnd);\r\n        // set a fallback timeout if the transition end event never fires, or is too slow\r\n        // transition end fallback: (animation duration + XXms)\r\n        self._timerId = setTimeout(onTransitionFallback, (dur + TRANSITION_END_FALLBACK_PADDING_MS));\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _playEnd(stepValue) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child._playEnd(stepValue);\r\n            }\r\n        }\r\n        if (this._hasDur) {\r\n            if (stepValue !== undefined) {\r\n                // too late to have a smooth animation, just finish it\r\n                // ******** DOM WRITE ****************\r\n                this._setTrans(0, true);\r\n                // ensure the ending progress step gets rendered\r\n                // ******** DOM WRITE ****************\r\n                this._progress(stepValue);\r\n            }\r\n            // set the after styles\r\n            // ******** DOM WRITE ****************\r\n            this._setAfterStyles();\r\n            // remove the will-change properties\r\n            // ******** DOM WRITE ****************\r\n            this._willChange(false);\r\n        }\r\n    }\r\n    /**\r\n     * NO DOM\r\n     * RECURSION\r\n     */\r\n    _hasDuration(opts) {\r\n        if (this.getDuration(opts) > DURATION_MIN) {\r\n            return true;\r\n        }\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                if (child._hasDuration(opts)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * NO DOM\r\n     * RECURSION\r\n     */\r\n    _hasDomReads() {\r\n        if (this._readCallbacks && this._readCallbacks.length > 0) {\r\n            return true;\r\n        }\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                if (child._hasDomReads()) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Immediately stop at the end of the animation.\r\n     */\r\n    stop(stepValue = 1) {\r\n        // ensure all past transition end events have been cleared\r\n        this._clearAsync();\r\n        this._hasDur = true;\r\n        this._playEnd(stepValue);\r\n    }\r\n    /**\r\n     * NO DOM\r\n     * NO RECURSION\r\n     */\r\n    _clearAsync() {\r\n        if (this._unregisterTrnsEnd) {\r\n            this._unregisterTrnsEnd();\r\n        }\r\n        if (this._timerId) {\r\n            clearTimeout(this._timerId);\r\n        }\r\n        this._timerId = this._unregisterTrnsEnd = undefined;\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     */\r\n    _progress(stepValue) {\r\n        // bread 'n butter\r\n        let val;\r\n        const elements = this._elements;\r\n        const effects = this._fxProperties;\r\n        if (!elements || elements.length === 0 || !effects || this._destroyed) {\r\n            return;\r\n        }\r\n        // flip the number if we're going in reverse\r\n        if (this._isReverse) {\r\n            stepValue = 1 - stepValue;\r\n        }\r\n        let i = 0;\r\n        let j = 0;\r\n        let finalTransform = '';\r\n        let fx;\r\n        for (i = 0; i < effects.length; i++) {\r\n            fx = effects[i];\r\n            if (fx.from && fx.to) {\r\n                const fromNum = fx.from.num;\r\n                const toNum = fx.to.num;\r\n                const tweenEffect = (fromNum !== toNum);\r\n                if (tweenEffect) {\r\n                    this._hasTweenEffect = true;\r\n                }\r\n                if (stepValue === 0) {\r\n                    // FROM\r\n                    val = fx.from.val;\r\n                }\r\n                else if (stepValue === 1) {\r\n                    // TO\r\n                    val = fx.to.val;\r\n                }\r\n                else if (tweenEffect) {\r\n                    // EVERYTHING IN BETWEEN\r\n                    const valNum = (((toNum - fromNum) * stepValue) + fromNum);\r\n                    const unit = fx.to.effectUnit;\r\n                    val = valNum + unit;\r\n                }\r\n                if (val !== null) {\r\n                    const prop = fx.effectName;\r\n                    if (fx.trans) {\r\n                        finalTransform += prop + '(' + val + ') ';\r\n                    }\r\n                    else {\r\n                        for (j = 0; j < elements.length; j++) {\r\n                            // ******** DOM WRITE ****************\r\n                            elements[j].style.setProperty(prop, val);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // place all transforms on the same property\r\n        if (finalTransform.length > 0) {\r\n            if (!this._isReverse && stepValue !== 1 || this._isReverse && stepValue !== 0) {\r\n                finalTransform += 'translateZ(0px)';\r\n            }\r\n            for (i = 0; i < elements.length; i++) {\r\n                // ******** DOM WRITE ****************\r\n                elements[i].style.setProperty('transform', finalTransform);\r\n                elements[i].style.setProperty('-webkit-transform', finalTransform);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     */\r\n    _setTrans(dur, forcedLinearEasing) {\r\n        // Transition is not enabled if there are not effects\r\n        const elements = this._elements;\r\n        if (!elements || elements.length === 0 || !this._fxProperties) {\r\n            return;\r\n        }\r\n        // set the TRANSITION properties inline on the element\r\n        const easing = (forcedLinearEasing ? 'linear' : this.getEasing());\r\n        const durString = dur + 'ms';\r\n        for (const { style } of elements) {\r\n            if (dur > 0) {\r\n                // ******** DOM WRITE ****************\r\n                style.transitionDuration = durString;\r\n                // each animation can have a different easing\r\n                if (easing !== null) {\r\n                    // ******** DOM WRITE ****************\r\n                    style.transitionTimingFunction = easing;\r\n                }\r\n            }\r\n            else {\r\n                style.transitionDuration = '0';\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM READ\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _beforeAnimation() {\r\n        // fire off all the \"before\" function that have DOM READS in them\r\n        // elements will be in the DOM, however visibily hidden\r\n        // so we can read their dimensions if need be\r\n        // ******** DOM READ ****************\r\n        this._fireBeforeReadFunc();\r\n        // ******** DOM READS ABOVE / DOM WRITES BELOW ****************\r\n        // fire off all the \"before\" function that have DOM WRITES in them\r\n        // ******** DOM WRITE ****************\r\n        this._fireBeforeWriteFunc();\r\n        // stage all of the before css classes and inline styles\r\n        // ******** DOM WRITE ****************\r\n        this._setBeforeStyles();\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _setBeforeStyles() {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child._setBeforeStyles();\r\n            }\r\n        }\r\n        const elements = this._elements;\r\n        // before the animations have started\r\n        // only set before styles if animation is not reversed\r\n        if (!elements || elements.length === 0 || this._isReverse) {\r\n            return;\r\n        }\r\n        const addClasses = this._beforeAddClasses;\r\n        const removeClasses = this._beforeRemoveClasses;\r\n        for (const el of elements) {\r\n            const elementClassList = el.classList;\r\n            // css classes to add before the animation\r\n            if (addClasses) {\r\n                for (const c of addClasses) {\r\n                    // ******** DOM WRITE ****************\r\n                    elementClassList.add(c);\r\n                }\r\n            }\r\n            // css classes to remove before the animation\r\n            if (removeClasses) {\r\n                for (const c of removeClasses) {\r\n                    // ******** DOM WRITE ****************\r\n                    elementClassList.remove(c);\r\n                }\r\n            }\r\n            // inline styles to add before the animation\r\n            if (this._beforeStyles) {\r\n                for (const [key, value] of Object.entries(this._beforeStyles)) {\r\n                    // ******** DOM WRITE ****************\r\n                    el.style.setProperty(key, value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM READ\r\n     * RECURSION\r\n     */\r\n    _fireBeforeReadFunc() {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM READ ****************\r\n                child._fireBeforeReadFunc();\r\n            }\r\n        }\r\n        const readFunctions = this._readCallbacks;\r\n        if (readFunctions) {\r\n            for (const callback of readFunctions) {\r\n                // ******** DOM READ ****************\r\n                callback();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _fireBeforeWriteFunc() {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child._fireBeforeWriteFunc();\r\n            }\r\n        }\r\n        const writeFunctions = this._writeCallbacks;\r\n        if (writeFunctions) {\r\n            for (const callback of writeFunctions) {\r\n                // ******** DOM WRITE ****************\r\n                callback();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     */\r\n    _setAfterStyles() {\r\n        const elements = this._elements;\r\n        if (!elements) {\r\n            return;\r\n        }\r\n        for (const el of elements) {\r\n            const elementClassList = el.classList;\r\n            // remove the transition duration/easing\r\n            // ******** DOM WRITE ****************\r\n            el.style.transitionDuration = el.style.transitionTimingFunction = '';\r\n            if (this._isReverse) {\r\n                // finished in reverse direction\r\n                // css classes that were added before the animation should be removed\r\n                const beforeAddClasses = this._beforeAddClasses;\r\n                if (beforeAddClasses) {\r\n                    for (const c of beforeAddClasses) {\r\n                        elementClassList.remove(c);\r\n                    }\r\n                }\r\n                // css classes that were removed before the animation should be added\r\n                const beforeRemoveClasses = this._beforeRemoveClasses;\r\n                if (beforeRemoveClasses) {\r\n                    for (const c of beforeRemoveClasses) {\r\n                        elementClassList.add(c);\r\n                    }\r\n                }\r\n                // inline styles that were added before the animation should be removed\r\n                const beforeStyles = this._beforeStyles;\r\n                if (beforeStyles) {\r\n                    for (const propName of Object.keys(beforeStyles)) {\r\n                        // ******** DOM WRITE ****************\r\n                        el.style.removeProperty(propName);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // finished in forward direction\r\n                // css classes to add after the animation\r\n                const afterAddClasses = this._afterAddClasses;\r\n                if (afterAddClasses) {\r\n                    for (const c of afterAddClasses) {\r\n                        // ******** DOM WRITE ****************\r\n                        elementClassList.add(c);\r\n                    }\r\n                }\r\n                // css classes to remove after the animation\r\n                const afterRemoveClasses = this._afterRemoveClasses;\r\n                if (afterRemoveClasses) {\r\n                    for (const c of afterRemoveClasses) {\r\n                        // ******** DOM WRITE ****************\r\n                        elementClassList.remove(c);\r\n                    }\r\n                }\r\n                // inline styles to add after the animation\r\n                const afterStyles = this._afterStyles;\r\n                if (afterStyles) {\r\n                    for (const [key, value] of Object.entries(afterStyles)) {\r\n                        el.style.setProperty(key, value);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     */\r\n    _willChange(addWillChange) {\r\n        let wc;\r\n        const effects = this._fxProperties;\r\n        let willChange;\r\n        if (addWillChange && effects) {\r\n            wc = [];\r\n            for (const effect of effects) {\r\n                const propWC = effect.wc;\r\n                if (propWC === 'webkitTransform') {\r\n                    wc.push('transform', '-webkit-transform');\r\n                }\r\n                else if (propWC !== undefined) {\r\n                    wc.push(propWC);\r\n                }\r\n            }\r\n            willChange = wc.join(',');\r\n        }\r\n        else {\r\n            willChange = '';\r\n        }\r\n        const elements = this._elements;\r\n        if (elements) {\r\n            for (const el of elements) {\r\n                // ******** DOM WRITE ****************\r\n                el.style.setProperty('will-change', willChange);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Start the animation with a user controlled progress.\r\n     */\r\n    progressStart() {\r\n        // ensure all past transition end events have been cleared\r\n        this._clearAsync();\r\n        // ******** DOM READ/WRITE ****************\r\n        this._beforeAnimation();\r\n        // ******** DOM WRITE ****************\r\n        this._progressStart();\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _progressStart() {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child._progressStart();\r\n            }\r\n        }\r\n        // force no duration, linear easing\r\n        // ******** DOM WRITE ****************\r\n        this._setTrans(0, true);\r\n        // ******** DOM WRITE ****************\r\n        this._willChange(true);\r\n    }\r\n    /**\r\n     * Set the progress step for this animation.\r\n     * progressStep() is not debounced, so it should not be called faster than 60FPS.\r\n     */\r\n    progressStep(stepValue) {\r\n        // only update if the last update was more than 16ms ago\r\n        stepValue = Math.min(1, Math.max(0, stepValue));\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child.progressStep(stepValue);\r\n            }\r\n        }\r\n        // ******** DOM WRITE ****************\r\n        this._progress(stepValue);\r\n    }\r\n    /**\r\n     * End the progress animation.\r\n     */\r\n    progressEnd(shouldComplete, currentStepValue, dur = -1) {\r\n        if (this._isReverse) {\r\n            // if the animation is going in reverse then\r\n            // flip the step value: 0 becomes 1, 1 becomes 0\r\n            currentStepValue = 1 - currentStepValue;\r\n        }\r\n        const stepValue = shouldComplete ? 1 : 0;\r\n        const diff = Math.abs(currentStepValue - stepValue);\r\n        if (dur < 0) {\r\n            dur = this._duration || 0;\r\n        }\r\n        else if (diff < 0.05) {\r\n            dur = 0;\r\n        }\r\n        this._isAsync = (dur > 30);\r\n        this._progressEnd(shouldComplete, stepValue, dur, this._isAsync);\r\n        if (this._isAsync) {\r\n            // for the root animation only\r\n            // set the async TRANSITION END event\r\n            // and run onFinishes when the transition ends\r\n            // ******** DOM WRITE ****************\r\n            this._asyncEnd(dur, shouldComplete);\r\n            // this animation has a duration so we need another RAF\r\n            // for the CSS TRANSITION properties to kick in\r\n            if (!this._destroyed) {\r\n                raf(() => {\r\n                    this._playToStep(stepValue);\r\n                });\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _progressEnd(shouldComplete, stepValue, dur, isAsync) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child._progressEnd(shouldComplete, stepValue, dur, isAsync);\r\n            }\r\n        }\r\n        if (!isAsync) {\r\n            // stop immediately\r\n            // set all the animations to their final position\r\n            // ******** DOM WRITE ****************\r\n            this._progress(stepValue);\r\n            this._willChange(false);\r\n            this._setAfterStyles();\r\n            this._didFinish(shouldComplete);\r\n        }\r\n        else {\r\n            // animate it back to it's ending position\r\n            this.isPlaying = true;\r\n            this.hasCompleted = false;\r\n            this._hasDur = true;\r\n            // ******** DOM WRITE ****************\r\n            this._willChange(true);\r\n            this._setTrans(dur, false);\r\n        }\r\n    }\r\n    /**\r\n     * Add a callback to fire when the animation has finished.\r\n     */\r\n    onFinish(callback, opts) {\r\n        if (opts && opts.clearExistingCallbacks) {\r\n            this._onFinishCallbacks = this._onFinishOneTimeCallbacks = undefined;\r\n        }\r\n        if (opts && opts.oneTimeCallback) {\r\n            this._onFinishOneTimeCallbacks = this._onFinishOneTimeCallbacks || [];\r\n            this._onFinishOneTimeCallbacks.push(callback);\r\n        }\r\n        else {\r\n            this._onFinishCallbacks = this._onFinishCallbacks || [];\r\n            this._onFinishCallbacks.push(callback);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * NO DOM\r\n     * RECURSION\r\n     */\r\n    _didFinishAll(hasCompleted, finishAsyncAnimations, finishNoDurationAnimations) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child._didFinishAll(hasCompleted, finishAsyncAnimations, finishNoDurationAnimations);\r\n            }\r\n        }\r\n        if (finishAsyncAnimations && this._isAsync || finishNoDurationAnimations && !this._isAsync) {\r\n            this._didFinish(hasCompleted);\r\n        }\r\n    }\r\n    /**\r\n     * NO RECURSION\r\n     */\r\n    _didFinish(hasCompleted) {\r\n        this.isPlaying = false;\r\n        this.hasCompleted = hasCompleted;\r\n        if (this._onFinishCallbacks) {\r\n            // run all finish callbacks\r\n            for (const callback of this._onFinishCallbacks) {\r\n                callback(this);\r\n            }\r\n        }\r\n        if (this._onFinishOneTimeCallbacks) {\r\n            // run all \"onetime\" finish callbacks\r\n            for (const callback of this._onFinishOneTimeCallbacks) {\r\n                callback(this);\r\n            }\r\n            this._onFinishOneTimeCallbacks.length = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Reverse the animation.\r\n     */\r\n    reverse(shouldReverse = true) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child.reverse(shouldReverse);\r\n            }\r\n        }\r\n        this._isReverse = !!shouldReverse;\r\n        return this;\r\n    }\r\n    /**\r\n     * Recursively destroy this animation and all child animations.\r\n     */\r\n    destroy() {\r\n        this._didFinish(false);\r\n        this._destroyed = true;\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child.destroy();\r\n            }\r\n        }\r\n        this._clearAsync();\r\n        if (this._elements) {\r\n            this._elements.length = 0;\r\n        }\r\n        if (this._readCallbacks) {\r\n            this._readCallbacks.length = 0;\r\n        }\r\n        if (this._writeCallbacks) {\r\n            this._writeCallbacks.length = 0;\r\n        }\r\n        this.parent = undefined;\r\n        if (this._childAnimations) {\r\n            this._childAnimations.length = 0;\r\n        }\r\n        if (this._onFinishCallbacks) {\r\n            this._onFinishCallbacks.length = 0;\r\n        }\r\n        if (this._onFinishOneTimeCallbacks) {\r\n            this._onFinishOneTimeCallbacks.length = 0;\r\n        }\r\n    }\r\n    /**\r\n     * NO DOM\r\n     */\r\n    _transEl() {\r\n        // get the lowest level element that has an Animator\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                const targetEl = child._transEl();\r\n                if (targetEl) {\r\n                    return targetEl;\r\n                }\r\n            }\r\n        }\r\n        return (this._hasTweenEffect &&\r\n            this._hasDur &&\r\n            this._elements !== undefined &&\r\n            this._elements.length > 0 ?\r\n            this._elements[0] : null);\r\n    }\r\n}\n\nconst create = (animationBuilder, baseEl, opts) => {\r\n    if (animationBuilder) {\r\n        return animationBuilder(Animator, baseEl, opts);\r\n    }\r\n    return Promise.resolve(new Animator());\r\n};\n\nexport { create };\n"]},"metadata":{},"sourceType":"module"}